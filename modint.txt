class mint {
public:int v;
	  mint(int v = 0) { s(v % mod); }
	  constexpr static int mod = 1e9 + 7;
	  constexpr static int fn_ = 500005;
	  static mint fact[fn_], comp[fn_];
	  mint pow(mint x) const {
		  mint b(v), c(1);
		  while (x.v) {
			  if (x.v & 1) c *= b;
			  b *= b;
			  x.v >>= 1;
		  }
		  return c;
	  }
	  inline mint& s(int vv) {
		  v = vv < mod ? vv : vv - mod;
		  return *this;
	  }
	  mint pow(int x) const { return pow(mint(x)); }
	  mint inv()const { return pow(mod - 2); }
	  mint operator-()const { return mint() - *this; }
	  mint& operator+=(const mint b) { return s(v + b.v); }
	  mint& operator-=(const mint b) { return s(v + mod - b.v); }
	  mint& operator*=(const mint b) { v = v * b.v % mod; return *this; }
	  mint& operator/=(const mint b) { (*this) *= b.inv(); }
	  mint operator+(const mint b) const { return mint(v) += b; }
	  mint operator-(const mint b) const { return mint(v) -= b; }
	  mint operator*(const mint b) const { return mint(v) *= b; }
	  mint operator/(const mint b) const { return mint(v) /= b; }
	  mint& operator+=(const int b) { v = (v + b) % mod; return *this; }
	  mint& operator-=(const int b) { v = (v - b) % mod + mod; return s(v); }
	  mint& operator*=(const int b) { v = v * b % mod; return *this; }
	  mint& operator/=(const int b) { (*this) *= mint(b).inv(); }
	  mint operator+(const int b) const { return mint(v) += b; }
	  mint operator-(const int b) const { return mint(v) -= b; }
	  mint operator*(const int b) const { return mint(v) *= b; }
	  mint operator/(const int b) const { return mint(v) /= b; }
	  friend ostream& operator<<(ostream& os, const mint& m) {
		  return os << m.v;
	  }
	  friend istream& operator>>(istream& is, mint& m) {
		  int x; is >> x; m = mint(x);
		  return is;
	  }
	  bool operator<(const mint& r)const { return v < r.v; }
	  bool operator>(const mint& r)const { return v > r.v; }
	  bool operator<=(const mint& r)const { return v <= r.v; }
	  bool operator>=(const mint& r)const { return v >= r.v; }
	  bool operator==(const mint& r)const { return v == r.v; }
	  bool operator!=(const mint& r)const { return v != r.v; }
	  explicit operator bool()const { return v; }
	  mint comb(mint k) {
		  if (k > * this) return mint();
		  if (!fact[0]) combini();
		  if (v >= fn_) {
			  if (k > * this - k) k = *this - k;
			  mint tmp(1);
			  for (int i = v; i >= v - k.v + 1; i--) tmp *= mint(i);
			  return tmp * comp[k.v];
		  }
		  else return fact[v] * comp[k.v] * comp[v - k.v];
	  }//nCk
	  mint comb(int k) { return comb(mint(k)); }
	  static void combini() {
		  fact[0] = 1;
		  for (int i = 1; i < fn_; i++) fact[i] = fact[i - 1] * mint(i);
		  comp[fn_ - 1] = fact[fn_ - 1].inv();
		  for (int i = fn_ - 2; i >= 0; i--) comp[i] = comp[i + 1] * mint(i + 1);
	  }
}; mint mint::fact[fn_], mint::comp[fn_];